<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Closures - Interview Prep</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }
        h1 { color: #2c3e50; margin-bottom: 1rem; }
        h2 { color: #34495e; margin: 2rem 0 1rem; }
        h3 { color: #2980b9; margin: 1.5rem 0 0.5rem; }
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
        }
        .output {
            background: #1a1a2e;
            color: #00ff00;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            margin: 1rem 0;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            margin: 1rem 0;
        }
        .tip {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.5rem 0.5rem 0.5rem 0;
        }
        button:hover { background: #2980b9; }
        .back-link { margin-bottom: 1rem; display: inline-block; }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">â† Back to Index</a>
    
    <h1>ğŸ”’ JavaScript Closures</h1>
    <p>Understanding lexical scope and data encapsulation in JavaScript.</p>

    <!--
    =========================================================================
    CLOSURES - Core Concept
    =========================================================================
    
    A CLOSURE is a function that has access to variables from its outer
    (enclosing) scope, even after the outer function has returned.
    
    KEY POINTS:
    
    1. Functions remember the environment where they were created
    2. Inner functions have access to outer function's variables
    3. This access persists even after outer function returns
    4. Each closure has its own copy of the outer variables
    
    USE CASES:
    - Data privacy / encapsulation
    - Function factories
    - Partial application / currying
    - Maintaining state in async operations
    - Module pattern
    -->

    <h2>What is a Closure?</h2>
    <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CLOSURE VISUALIZATION                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   function outer() {                                            â”‚
â”‚       let count = 0;  â—„â”€â”€â”€â”€â”€â”€â”€ Outer variable                   â”‚
â”‚                                                                  â”‚
â”‚       return function inner() {  â—„â”€â”€ Inner function             â”‚
â”‚           count++;                                               â”‚
â”‚           return count;  â—„â”€â”€â”€â”€â”€â”€ Accesses outer's variable      â”‚
â”‚       }                                                          â”‚
â”‚   }                                                              â”‚
â”‚                                                                  â”‚
â”‚   const counter = outer();  â—„â”€â”€â”€ outer() returns inner          â”‚
â”‚   counter();  // 1          â—„â”€â”€â”€ inner still has access to countâ”‚
â”‚   counter();  // 2          â—„â”€â”€â”€ count persists between calls   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  CLOSURE = inner function + its lexical environment     â”‚   â”‚
â”‚   â”‚            (the variables it "closes over")             â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </div>

    <h2>Example 1: Basic Closure</h2>
    <pre>
/**
 * BASIC CLOSURE EXAMPLE
 * 
 * The inner function "closes over" the outer variable.
 * It maintains access even after outer() has returned.
 */

function createGreeting(greeting) {
    // 'greeting' is in the outer scope
    
    return function(name) {
        // This inner function has access to 'greeting'
        // even after createGreeting() has finished
        return `${greeting}, ${name}!`;
    };
}

// Create closures with different greetings
const sayHello = createGreeting('Hello');
const sayHi = createGreeting('Hi');

console.log(sayHello('Alice'));  // "Hello, Alice!"
console.log(sayHi('Bob'));       // "Hi, Bob!"

// Each closure has its OWN copy of 'greeting'
// sayHello's greeting = 'Hello'
// sayHi's greeting = 'Hi'
    </pre>
    <button onclick="runExample1()">Run Example</button>
    <div id="output1" class="output"></div>

    <h2>Example 2: Counter with Private State</h2>
    <pre>
/**
 * DATA PRIVACY WITH CLOSURES
 * 
 * Closures allow us to create private variables that can't be
 * accessed directly from outside.
 */

function createCounter() {
    let count = 0;  // Private variable - not accessible outside
    
    return {
        increment() {
            count++;
            return count;
        },
        decrement() {
            count--;
            return count;
        },
        getCount() {
            return count;
        }
    };
}

const counter = createCounter();

console.log(counter.getCount());   // 0
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.decrement());  // 1

// count is PRIVATE - can't access directly
console.log(counter.count);  // undefined

// Each counter has its own private count
const counter2 = createCounter();
console.log(counter2.getCount());  // 0 (independent)
    </pre>
    <button onclick="runExample2()">Run Example</button>
    <div id="output2" class="output"></div>

    <h2>Example 3: Function Factory</h2>
    <pre>
/**
 * FUNCTION FACTORY PATTERN
 * 
 * Create specialized functions by "baking in" certain parameters.
 */

function multiply(x) {
    return function(y) {
        return x * y;
    };
}

// Create specialized multiplier functions
const double = multiply(2);
const triple = multiply(3);
const quadruple = multiply(4);

console.log(double(5));     // 10
console.log(triple(5));     // 15
console.log(quadruple(5));  // 20

// More practical example: API endpoint factory
function createApiEndpoint(baseUrl) {
    return function(path) {
        return `${baseUrl}${path}`;
    };
}

const api = createApiEndpoint('https://api.example.com');
console.log(api('/users'));     // https://api.example.com/users
console.log(api('/products'));  // https://api.example.com/products
    </pre>
    <button onclick="runExample3()">Run Example</button>
    <div id="output3" class="output"></div>

    <h2>Example 4: Classic Loop Problem</h2>
    <pre>
/**
 * THE CLASSIC CLOSURE LOOP PROBLEM
 * 
 * This is a VERY common interview question!
 */

// PROBLEM: Using var in a loop
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log('var:', i);
    }, 100);
}
// Output: 3, 3, 3 (not 0, 1, 2!)
// Why? var is function-scoped, all callbacks share the same 'i'

// ============================================

// SOLUTION 1: Use let (block-scoped)
for (let j = 0; j < 3; j++) {
    setTimeout(function() {
        console.log('let:', j);
    }, 100);
}
// Output: 0, 1, 2 (correct!)
// Each iteration gets its own 'j'

// ============================================

// SOLUTION 2: Create closure with IIFE
for (var k = 0; k < 3; k++) {
    (function(index) {
        setTimeout(function() {
            console.log('IIFE:', index);
        }, 100);
    })(k);  // Pass k as argument, creating new scope
}
// Output: 0, 1, 2 (correct!)

// ============================================

// SOLUTION 3: Use forEach (creates new scope per iteration)
[0, 1, 2].forEach(function(num) {
    setTimeout(function() {
        console.log('forEach:', num);
    }, 100);
});
// Output: 0, 1, 2 (correct!)
    </pre>
    <button onclick="runExample4()">Run Example</button>
    <div id="output4" class="output"></div>

    <h2>Example 5: Module Pattern</h2>
    <pre>
/**
 * MODULE PATTERN
 * 
 * Uses closures to create modules with private and public members.
 * This was the standard pattern before ES6 modules.
 */

const Calculator = (function() {
    // Private variables
    let result = 0;
    let history = [];
    
    // Private function
    function addToHistory(operation) {
        history.push(operation);
    }
    
    // Public API (returned object)
    return {
        add(x) {
            result += x;
            addToHistory(`+ ${x}`);
            return this;  // Enable chaining
        },
        subtract(x) {
            result -= x;
            addToHistory(`- ${x}`);
            return this;
        },
        multiply(x) {
            result *= x;
            addToHistory(`* ${x}`);
            return this;
        },
        getResult() {
            return result;
        },
        getHistory() {
            return [...history];  // Return copy to protect original
        },
        reset() {
            result = 0;
            history = [];
            return this;
        }
    };
})();  // IIFE - immediately invoked

// Usage
Calculator.add(10).multiply(2).subtract(5);
console.log(Calculator.getResult());   // 15
console.log(Calculator.getHistory());  // ['+ 10', '* 2', '- 5']

// Private variables are protected
console.log(Calculator.result);   // undefined
console.log(Calculator.history);  // undefined
    </pre>
    <button onclick="runExample5()">Run Example</button>
    <div id="output5" class="output"></div>

    <h2>Example 6: Memoization with Closures</h2>
    <pre>
/**
 * MEMOIZATION
 * 
 * Use closures to cache expensive function results.
 */

function memoize(fn) {
    const cache = {};  // Closure over cache
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache[key]) {
            console.log('Cache hit for:', key);
            return cache[key];
        }
        
        console.log('Computing for:', key);
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// Expensive function
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Memoized version
const memoizedFib = memoize(function fib(n) {
    if (n <= 1) return n;
    return memoizedFib(n - 1) + memoizedFib(n - 2);
});

console.log(memoizedFib(10));  // Computing... 55
console.log(memoizedFib(10));  // Cache hit! 55
    </pre>
    <button onclick="runExample6()">Run Example</button>
    <div id="output6" class="output"></div>

    <div class="warning">
        <h3>âš ï¸ Memory Considerations</h3>
        <p>Closures keep references to outer variables, which can prevent garbage collection:</p>
        <pre>
function createHeavyClosure() {
    const largeData = new Array(1000000).fill('data');
    
    return function() {
        // Even if we don't use largeData, it's kept in memory
        return 'Hello';
    };
}

// largeData stays in memory as long as the closure exists
const closure = createHeavyClosure();

// To free memory, set closure to null when done
// closure = null;
        </pre>
    </div>

    <h2>ğŸ¤ Interview Questions</h2>
    <div class="tip">
        <h3>Q1: What is a closure?</h3>
        <p>A closure is a function that has access to variables from its outer (enclosing) scope, even after the outer function has returned. It "closes over" those variables.</p>
        
        <h3>Q2: What are practical uses of closures?</h3>
        <ul>
            <li>Data privacy / encapsulation</li>
            <li>Function factories</li>
            <li>Partial application / currying</li>
            <li>Memoization / caching</li>
            <li>Module pattern</li>
            <li>Event handlers with state</li>
        </ul>
        
        <h3>Q3: How do closures affect memory?</h3>
        <p>Closures keep references to outer scope variables, preventing garbage collection. This can cause memory leaks if not managed properly.</p>
        
        <h3>Q4: Explain the loop closure problem</h3>
        <p>When using <code>var</code> in a loop with async callbacks, all callbacks share the same variable. Use <code>let</code> (block-scoped) or IIFE to create separate closures.</p>
    </div>

    <script>
        function captureOutput(fn, outputId) {
            const output = document.getElementById(outputId);
            output.innerHTML = '';
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                output.innerHTML = logs.join('\n');
                originalLog.apply(console, args);
            };
            fn();
            setTimeout(() => { console.log = originalLog; }, 500);
        }

        function runExample1() {
            captureOutput(() => {
                function createGreeting(greeting) {
                    return function(name) {
                        return `${greeting}, ${name}!`;
                    };
                }
                const sayHello = createGreeting('Hello');
                const sayHi = createGreeting('Hi');
                console.log(sayHello('Alice'));
                console.log(sayHi('Bob'));
            }, 'output1');
        }

        function runExample2() {
            captureOutput(() => {
                function createCounter() {
                    let count = 0;
                    return {
                        increment() { return ++count; },
                        decrement() { return --count; },
                        getCount() { return count; }
                    };
                }
                const counter = createCounter();
                console.log('Initial:', counter.getCount());
                console.log('After increment:', counter.increment());
                console.log('After increment:', counter.increment());
                console.log('After decrement:', counter.decrement());
                console.log('counter.count:', counter.count);
            }, 'output2');
        }

        function runExample3() {
            captureOutput(() => {
                function multiply(x) {
                    return function(y) { return x * y; };
                }
                const double = multiply(2);
                const triple = multiply(3);
                console.log('double(5):', double(5));
                console.log('triple(5):', triple(5));
            }, 'output3');
        }

        function runExample4() {
            captureOutput(() => {
                console.log('Using let:');
                for (let j = 0; j < 3; j++) {
                    setTimeout(() => console.log('  j =', j), j * 50);
                }
            }, 'output4');
        }

        function runExample5() {
            captureOutput(() => {
                const Calculator = (function() {
                    let result = 0;
                    let history = [];
                    return {
                        add(x) { result += x; history.push(`+ ${x}`); return this; },
                        subtract(x) { result -= x; history.push(`- ${x}`); return this; },
                        multiply(x) { result *= x; history.push(`* ${x}`); return this; },
                        getResult() { return result; },
                        getHistory() { return [...history]; }
                    };
                })();
                Calculator.add(10).multiply(2).subtract(5);
                console.log('Result:', Calculator.getResult());
                console.log('History:', Calculator.getHistory().join(', '));
                console.log('Calculator.result:', Calculator.result);
            }, 'output5');
        }

        function runExample6() {
            captureOutput(() => {
                function memoize(fn) {
                    const cache = {};
                    return function(...args) {
                        const key = JSON.stringify(args);
                        if (cache[key]) {
                            console.log('Cache hit for:', key);
                            return cache[key];
                        }
                        console.log('Computing for:', key);
                        const result = fn.apply(this, args);
                        cache[key] = result;
                        return result;
                    };
                }
                const memoizedAdd = memoize((a, b) => a + b);
                console.log('Result:', memoizedAdd(2, 3));
                console.log('Result:', memoizedAdd(2, 3));
                console.log('Result:', memoizedAdd(5, 5));
            }, 'output6');
        }
    </script>
</body>
</html>